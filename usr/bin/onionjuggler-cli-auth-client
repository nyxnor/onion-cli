#!/usr/bin/env sh

## manage client authorization client side (ClientOnionAuthDir)

onionjuggler_defaults="/usr/share/onionjuggler/defaults.sh"
[ -e "${onionjuggler_defaults}" ] || { printf '%s\n' "${onionjuggler_defaults} does not exist"; exit 1; }
[ -f "${onionjuggler_defaults}" ] || { printf '%s\n' "${onionjuggler_defaults} is not a regular file"; exit 1; }
[ -r "${onionjuggler_defaults}" ] || { printf '%s\n' "${onionjuggler_defaults} can not be read"; exit 1; }
. "${onionjuggler_defaults}"
source_conf

me="${0##*/}"
check_plugin_enabled "${me}" || error_msg "Plugin '${me}' is disabled by configuration"

usage(){
  printf %s"Usage: ${me} [--option <ARGUMENT>]
Description: client side onion authorization
Complete options:
  --on [--client-priv-file <FILE>] [--replace-file]
                            import '.auth_private' file to ClientOnionAuthDir
  --on [--client <CLIENT>] [--onion <ONION>] [--client-priv-key <CLIENT_PRIV_KEY>] [--replace-file]
                            generate keys for client authorization, optionally add define client's private key
  --off [--client <CLIENT1,CLIENT2,...>]
                            remove client-side credential based on client name
  --list                    list client-side credentials
"
  exit 1
}

########################
#### OPTION PARSING ####

## hacky getopts
## accepts long (--option) and short (-o) options
## accept argument assignment with space (--option arg | -o arg) or equal sign (--option=arg | -o=arg)
[ -z "${1}" ] && usage
while :; do
  shift_n=""
  opt_orig="${1}" ## save opt orig for error message to understand which opt failed
  # shellcheck disable=SC2034
  arg_possible="${2}" ## need to pass the second positional parameter because maybe it is an argument
  clean_opt "${1}" || break
  case "${opt}" in
    on|off|list|n|f|l) status="${opt}";;
    client-priv-file|client-priv-file=*) get_arg client_priv_file;;
    replace-file) replace_file="${opt}";;
    o|onion|o=*|onion=*) get_arg onion_hostname;;
    client-priv-key|client-priv-key=*) get_arg client_priv_key;;
    client|client=*) get_arg client;;
    h|help) usage;;
    *) error_msg "Invalid option: '${opt_orig}'";;
  esac
  ## shift as many times as demanded
  ## if empty, shift at least once to pass to next option
  shift "${shift_n:-1}"
  [ -z "${1}" ] && break
done

[ "$(id -u)" -ne 0 ] && error_msg "run as root"
case "${status}" in


  ## as the onion service client, add a key given by the onion service operator to authenticate yourself inside ClientOnionAuthDir
  ## The suffix '.auth_private' should not be mentioned, it will be automatically inserted when mentioning the name of the file.
  ## private key format must be: <onion-addr-without-.onion-part>:descriptor:x25519:<private-key>
  ## use the onion hostname as the file name, this avoid overriding the file by mistake and it indicates outside of the file for which service it refers to (of course it is written inside also)
  ## adding to Tor Browser automatically not supported yet
  n|on)

    auth_client_check_file(){
      test -f "${client_priv_file}" || error_msg "file ${client_priv_file} does not exist or is not a regular file"
      client_priv_file_name="${client_priv_file##*/}"
      [ "${client_priv_file_name%%*[^a-zA-Z0-9_.-]*}" ] || error_msg "file name can only contain letters, numbers, hifen, underscore and dot"
      ## avoid copying wrong file to the auth dir
      echo "${client_priv_file_name}" | grep -q ".auth_private$" || error_msg "file name does not end with '.auth_private'"
      wc -c "${client_priv_file}" | grep -q "^128 " || error_msg "file size '$(wc -c "${client_priv_file}" | cut -d " " -f1)' is different than 128 bytes"
    }

    auth_client_check_replace(){
      file_type="${1}" # stdin|file
      client_priv_file="${2}"
      client_priv_file_name="${client_priv_file##*/}"
      if test -f "${tor_data_dir_auth}/${client_priv_file_name}"; then
        test -n "${replace_file}" || error_msg "file named ${client_priv_file_name} already exist on ${tor_data_dir_auth}, to replace it, use the option '--replace-file'"
      fi
      ## multiple files with the same contents leads to a tor error
      ## file case if it already exists, else stdin to compare key that is not in a file
      for auth in "${tor_data_dir_auth}"/*; do
        case "${file_type}" in
          file)
            if cmp -s "${auth}" "${client_priv_file}"; then
              [ "${auth##*/}" != "${client_priv_file_name}" ] && error_msg "file with the same contents already present on ${auth}"
            fi
          ;;
          stdin)
            if echo "${client_priv_key_config}" | cmp -s "${auth}"; then
              [ "${auth##*/}" != "${client_priv_file_name}" ] && error_msg "file with the same contents already present on ${auth}"
            fi
          ;;
        esac
      done
    }

    auth_client_check_content(){
      client_priv_file_content="${1}"
      echo "${client_priv_file_content}" | grep -q ":descriptor:x25519:" || error_msg "file contents does not contain pattern ':descriptor:x25519:"
      [ "${client_priv_file_content%%*[^a-zA-Z0-9:]*}" ] || error_msg "file contains special characters"
      client_priv_file_onion_found="$(echo "${client_priv_file_content}" | cut -d ":" -f1)"
      [ "${client_priv_file_onion_found%%*[^a-z2-7]*}" ] || error_msg "file's onion '${client_priv_file_onion_found}' is not within base32 alphabet lower-case encoding [a-z][2-7]"
      echo "${client_priv_file_content}" | cut -d ":" -f2 | grep -q "descriptor" || error_msg "file's descriptor reference not found in the 2nd field"
      echo "${client_priv_file_content}" | cut -d ":" -f3 | grep -q "x25519" || error_msg "file's descriptor type not found in the 3rd field"
      client_priv_file_priv_found="$(echo "${client_priv_file_content}" | cut -d ":" -f4)"
      [ "${client_priv_file_priv_found%%*[^A-Z2-7]*}" ] || error_msg "file's client private key '${client_priv_file_priv_found}' is not within base32 alphabet upper-case encoding [A-Z][2-7]"
    }

    create_clientonionauthdir(){
      ## make sure ClientOnionAuthDir exists
      read_tor_files
      # shellcheck disable=SC2086
      if ! grep -q "ClientOnionAuthDir" ${tor_config_files}; then
        safe_edit tmp tor_conf
        printf %s"\nClientOnionAuthDir ${tor_data_dir_auth}\n\n" | tee -a "${tor_conf_tmp}"
      fi
      test -d "${tor_data_dir_auth}" || mkdir -p "${tor_data_dir_auth}"
    }

    clean_onion(){
      check_opt_filled onion_hostname
      ## clean URL of protocol (http(s)://) and page (/index.html), tail 63 bytes to clean subdomain
      ## example of URL it is able to clean:
      ##  http://www.dds6qkxpwdeubwucdiaord2xgbbeyds25rbsgr73tbfpqpt4a6vjwsyd.onion/wiki/Remote_Administration
      onion_hostname="$(printf %s"${onion_hostname}\n" | sed "s|.*://||;s|/.*||" | tail -c 63)"
      onion_hostname_without_onion="${onion_hostname%.onion}"
      [ "${onion_hostname_without_onion%%*[^a-z2-7]*}" ] || error_msg "onion domain '${onion_hostname}' is not within base32 alphabet lower-case encoding [a-z][2-7]"
      [ "${#onion_hostname_without_onion}" = "56" ] || error_msg "onion domain '${onion_hostname}' has length of ${#onion_hostname}, different than 56 characters (<56-char-base32>.onion)"
    }

    create_clientonionauthdir
    if test -n "${client_priv_file}"; then
      auth_client_check_file
      auth_client_check_content "$(cat "${client_priv_file}")"
      auth_client_check_replace file "${client_priv_file}"
      notice "Copying file ${client_priv_file} to ${tor_data_dir_auth}/${client_priv_file_name}"
      cp "${client_priv_file}" "${tor_data_dir_auth}"

    elif test -n "${client_priv_key}"; then
      check_opt_filled client
      client="${client##*/}"
      check_name client
      clean_onion
      client_priv_key_config="${onion_hostname_without_onion}:descriptor:x25519:${client_priv_key}"
      auth_client_check_content "${client_priv_key_config}"
      client_priv_file_name="${client}.auth_private"
      auth_client_check_replace stdin "${client}.auth_private"
      printf %s"${client_priv_key_config}\n" | tee "${tor_data_dir_auth}/${client}.auth_private" >/dev/null
      notice "Client private key config saved to ${tor_data_dir_auth}/${client}.auth_private"
      notice "\nClient side authorization configured"
      notice "${bold}- Client priv conf:${nocolor} ${client_priv_key_config}"
      notice "\nNow it depends on the service operator to authorize your client public key"
      printf '\n'

    else
      check_opt_filled client
      client="${client##*/}"
      check_name client
      clean_onion
      gen_auth_key_pair
      auth_client_check_replace stdin "${client}.auth_private"
      printf %s"${client_priv_key_config}\n" | tee "${tor_data_dir_auth}/${client}.auth_private" >/dev/null
      notice "Client private key config saved to ${tor_data_dir_auth}/${client}.auth_private"
      notice "This is your private key config, keep it safe, keep it hidden:"
      notice "${bold}- Client priv conf:${nocolor} ${client_priv_key_config}"
      notice "\nNow it depends on the service operator to authorize your client public key"
      notice "Send the public key and instructions to the onion service operator of ${onion_hostname}"
      notice "${bold}- Client pub conf:${nocolor} ${client_pub_key_config}"
      printf '\n'
    fi

    signal_tor
  ;;


  ## as the onion service client, delete '.auth_private' files from ClientOnionAuthDir that are not valid or has no use anymore
  f|off)
    ! check_folder_is_not_empty "${tor_data_dir_auth}" && error_msg "ClientOnionAuthDir ${tor_data_dir_auth} is empty"
    check_opt_filled client

    auth_client_remove(){
      client="${1}"
      client="${client##*/}"
      client_clean="${client%.auth_private}"
      if test -f "${tor_data_dir_auth}/${client_clean}".auth_private; then
        notice "${red}Removing ${tor_data_dir_auth}/${client_clean}.auth_private${nocolor}"
        rm -fv "${tor_data_dir_auth}/${client_clean}".auth_private
      else
        error_msg "File ${tor_data_dir_auth}/${client_clean}.auth_private does not exist"
      fi
    }

    loop_list auth_client_remove "${client}"
    printf '\n'
    signal_tor
  ;;


  l|list)
    if check_folder_is_not_empty "${tor_data_dir_auth}"; then
      notice "${bold}ClientOnionAuthDir ${tor_data_dir_auth}${nocolor}"
      for auth in "${tor_data_dir_auth}"/*; do
        auth="${auth##*/}"
        notice "\n${bold}File name:${nocolor} ${auth}"
        notice "${bold}Content:${nocolor} $(grep "descriptor:x25519:" "${tor_data_dir_auth}"/"${auth}")"
      done
      printf "\n"
    else
      error_msg "ClientOnionAuthDir ${tor_data_dir_auth} is empty"
    fi
  ;;


  *) usage;;

esac
