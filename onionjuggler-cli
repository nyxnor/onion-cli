#!/usr/bin/env sh

## This script lets you manage your hidden services to all its capability
##
## Lines that begin with "## " try to explain what's going on. Lines
## that begin with just "#" are disabled commands.

## colors
nocolor="\033[0m"
bold="\033[1m"
underline="\033[4m"
red="\033[31m"
green="\033[32m"
yellow="\033[33m"
blue="\033[34m"
magenta="\033[35m"
cyan="\033[36m"

usage(){

  printf %s"${magenta}
                           ';:  -'''
                      ':' -=l.:>l_
                     '^';z;_|J/':'
                    '|;l''?7xc:'
                    r1ztJtv;':'
                   'xxxtx|-'
               ':' '|ttxv:
               7Or:{tx|'
                O?':,Jom,
                vN'_'i9@;
               'g9'_'j2Qg-
             _xBt-':'>USMQv'
          ;uQDc.'';_:'lOjoOBNu:
       ~yQ6|.'''':;_:,';DSjjj6#QX;
     ?BQv''''''-=>'_'l'''8yjjjujqQQi
   :R#>'''''->|r-''_'.7'';gjjuujjjPQN:
  7@7'''''rl>-''''.;:'-1.'OPjuuuujjjM@l
 i@:''''*i'''''''.;_*''.u'lQjuuuuuujjK@r
~@1''''u,'''''',::'_-J,',1~@SjjuuuujjjQQ'
}@'''.a.'''':>;.'''_''/,'e.@Ejjuuuuuujh@>
Z@'''],'''.v^'''''';_''u'l:@Kjjuuuuuuja@v
}@.''a'''-o''''''->^;;'*l>/@OjjuuuuuujX@|
_@v'':i''L,'''''_{'_'y''kJu@6jjuuuujjjN@-
 v@:''7r'l;'''''x''_'o':Eqe@ojjuuuujjE@L
  F@c''|=.R'''''u''_'o:lSjQQjjjuujjuO@}
   ?Qq,'rcr8,'''e,'_'q-kZv@EjuujujoNQ|
    'iQO^,xlm7-''E'_~g;DO@OjjjujhBQ1'
       :jWkmycjl^:FxPXQ@@kjSEDQQe;
          -;vmdgN@@Q@@@QROsev^-
${nocolor}

Juggle with an Onion Service
\nUsage: onionjuggler-cli command [--option <ARGUMENT>]
\nComplete options:
  on [--service <SERVICE>] [--socket <unix>] [--version <3>] [--port <VIRTPORT[,VIRTPORT2]>]
                                                             enable a service listening with tcp sockets
  on [--service <SERVICE>] [--socket <tcp>] [--version <3>] [--port <VIRTPORT[,TARGET][,VIRTPORT2][,TARGET2]>]
                                                             enable a service listening on unix sockets
  off [--purge] [--service <@all|SERV1,SERV2,...>            disable a service and optionally purge its directory
  list [--quiet] [--service <@all|SERV1,SERV2,...>]          see credentials from indicated services
  renew [--service <@all|SERV1,SERV2,...>]                   renew indicated services addresses
  auth-server --on [--service <SERVICE>] [--client <CLIENT>] [--client-pub-key <CLIENT_PUB_KEY>]
                                                             add client authorization, optionally add client's public key
  auth-server --on [--service <@all|SERV1,SERV2,...>] [--client <CLIENT1,CLIENT2,...>]
                                                             add client authorization
  auth-server --off [--service <@all|SERV1,SERV2,...>] [--client <@all|CLIENT1,CLIENT2,...>]
                                                             remove client authorization
  auth-server --list [--service <@all|SERV1,SERV2,...>]      list authorized clients for indicated service
  auth-client --on [--onion <ONION>] [--client-priv-key <CLIENT_PRIV_KEY>]
                                                             add authorization of client access, optionally add client's private key
  auth-client --off [--onion <ONION>]                        remove authorization of client access
  auth-client --list                                         list your keys as a client
  web --on [--service <SERVICE>] [--folder <SITE_PATH>]      start serving a website for certain service and its folder
  web --off [--service <SERVICE>]                            stop serving a website for certain service and its folder
  web --list                                                 list enabled websites
  location [--nginx|--apache2|--html] [--service <SERVICE>]  onion-location guide, no execution
  backup [--create|--integrate]                              backup onion services or integrate the backup
  vanguards [--on|--list|--off]                              install or upgrade, remove or see logs for vanguards addon
  -h|--help                                                  display this help message

Options:
  on                                                         activate an onion service
    -s, --service <SERVICE>                                  service to activate
    -S, --socket <tcp|unix>                                  define a socket for the new onion service
    -v, --version 3                                          define a version for the new onion service
    -p, --port <VIRTPORT[,TARGET],VIRTPORT2[,TARGET2]>       define ports for the new onion service
  off                                                        deactivate an onion service configuration
    -s, --service <SERV1,SERV2,...>                          service to deactivate
    -P, --purge                                              purge the onion service data
  list                                                       list existing services and their configuration, clients
    -s, --service <@all|SERV1,SERV2,...>                     list all services or a indicate them comma separated
    -q, --quiet                                              don't QR encode the hostname
  auth-server                                                manage authorized_clients
    -s, --service <@all|SERV1,SERV2,...>                     authorize or remove authorization to indicated services
    -n, --on                                                 authorized aclient
    -f, --off                                                remove authorization from a client
    -l, --list                                               list authorized clients
    -c, --client <CLIENT>                                    choose client
    -K, --client-pub-key <CLIENT_PUB_KEY>                    specify client pub key to authorize to one service
  auth-client                                                manage your authorizations to an onion
    -n, --on                                                 add authorization
    -f, --off                                                remove authorization
    -l, --list                                               list current authorizations
    -o, --onion <ONION>                                      specify onion to authenticate
    -k, --client-priv-key <CLIENT_PRIV_KEY>                  specify your client private key
  web                                                        manage web server configuration
    -s, --service <SERVICE>                                  service to enable or disable website
    -n, --on                                                 activate website to an onion service
    -f, --off                                                deactivate website to an onion service
    -l, --list                                               list active websites
    -w, --folder <SITE_PATH>                                 specify website files
  location                                                   guide to add onion-location to redirect users to your onion domain
    -s, --service <SERVICE>                                  indicate service to see onion-location string
    --nginx                                                  Nginx webserver header for onion-location
    --apache2                                                Apache2 webserver header for onion-location
    --html                                                   HTML header for onion-location
  backup                                                     complete backup of onion services
    -M, --make                                               make a backup
    -I, --integrate                                          integrate backup to your system
  vanguards                                                  manage Vanguards protection
    -n, --on                                                 install Vanguards addon, if already installed, upgrade.
    -f, --off                                                remove Vanguards
    -l, --list                                               see Vanguards logs
  restore-torrc                                              re

Advanced:
    -C, --config                                             specify an alternative onionjuggler.conf to be parsed
    -R, --restart                                            signal tor to restart when the daemon status is failed or inactive
    -r, --reload                                             signal tor to reload (default option)

Option names:
  command                                                    on, off, list, renew, auth-server, auth-client, web, location, vanguards
  status                                                     --on, --off, --list
  action                                                     --purge, --quiet, --nginx, --apache2, --html, --make, --integrate
  signal                                                     --restart, --reload

Positional arguments:
  @all                                                       all services or clients available
  SERV1,SERV2...                                             specify services
  CLIENT1,CLIENT2,...                                        specify clients

'# Done': You should always see it at the end, else something unexpected occured.
It does not imply the code worked, you should always pay attention for errors in the logs.
If your services are unreacheable, restart tor.
\nReport bugs to: https://github.com/nyxnor/onionsjuggler/issues\n"

  exit 1
}
[ -z "${1}" ] && usage

########################
#### OPTION PARSING ####

## display error message with instructions to use the script correctly.
error_msg(){ printf %s"${red}ERROR: ${1}${nocolor}\n"; exit 1; }

## assign_value variable_name "${opt}"
## it strips the dashes and assign the clean value to the variable
## assign_value status --on IS status=on
## variable_name is the name you want it to have
## $opt being options with single or double dashes that don't require arguments
assign_value(){
  case "${2}" in
    --*) value="${2#--}";;
    -*) value="${2#-}";;
    *) value="${2}"
  esac
  eval "${1}"="${value}"
}

## get_arg variable_name "${opt}" "${arg}"
## get_arg service --service ssh
## variable_name is the name you want it to have
## $opt being options with single or double dashes
## $arg is requiring and argument, else it fails
## assign_value "${1}" "${3}" means it is assining the argument ($3) to the variable_name ($1)
get_arg(){
  case "${3}" in
    ""|-*) error_msg "Option '${2}' requires an argument.";;
  esac
  assign_value "${1}" "${3}"
}

## hacky getopts
## 1. if the option requires argument, and the option is preceeded by single or double dash and it
##    can be it can be specified with '-s=ssh' or '-s ssh' or '--service=ssh' or '--service ssh'
##    use: get_arg variable_name "${opt}" "${arg}"
## 2. if a bunch of options that does different things are to be assigned to the same variable
##    and the option is preceeded by single or double dash use: assign_value variable_name "${opt}"
##    as this option does not require argument, specifu $shift_n=1
## 3. if the option does not start with dash and does not require argument, assign to command manually.
while :; do
  case "${1}" in
    -*=*) opt="${1%=*}"; arg="${1#*=}"; shift_n=1;;
    -*) opt="${1}"; arg="${2}"; shift_n=2;;
    *) opt="${1}"; arg="${2}"; shift_n=1;;
  esac
  case "${opt}" in
    on|off|list|renew|auth-server|auth-client|web|location|backup|vanguards|restore-torrc) command="${opt}";;
    --on|--off|--list|-n|-f|-l) assign_value status "${opt}"; shift_n=1;;
    -R|--restart|-r|--reload) assign_value signal "${opt}"; shift_n=1;;
    -P|--purge|--nginx|--apache2|--html|-q|--quiet|-M|--make|-I|--integrate) assign_value action "${opt}"; shift_n=1;;
    -s|--service|-s=*|--service=*) get_arg service "${opt}" "${arg}";;
    -c|--client|-c=*|--client=*) get_arg client "${opt}" "${arg}";;
    -o|--onion|-o=*|--onion=*) get_arg onion "${opt}" "${arg}";;
    -v|--version|-v=*|--version=*) get_arg version "${opt}" "${arg}";;
    -S|--socket|-S=*|--socket=*) get_arg socket "${opt}" "${arg}";;
    -p|--port|-p=*|--port=*) get_arg port "${opt}" "${arg}";;
    -w|--folder|-w=*|--folder=*) get_arg folder "${opt}" "${arg}";;
    -k|--client-priv-key|-k=*|--client-priv-key=*) get_arg client_priv_key "${opt}" "${arg}";;
    -K|--client-pub-key|-K=*|--client-pub-key=*) get_arg client_pub_key "${opt}" "${arg}";;
    -C|--config|-C=*|--config=*) get_arg ONIONJUGGLER_CONF "${opt}" "${arg}";;
    "") break;;
    *) error_msg "Invalid option: ${opt}";;
  esac
  shift "${shift_n}"
done

###################
#### VARIABLES ####

## 1. source default configuration file first
## 2. source local (user made) configuration files to override the default values
## 3. source the ONIONJUGGLER_CONF specified by the cli argument and if it empty, use the environment variable
[ ! -f /etc/onionjuggler/onionjuggler.conf ] && error_msg "Default configuration file not found: /etc/onionjuggler/onionjuggler.conf"
[ -r /etc/onionjuggler/onionjuggler.conf ] && . /etc/onionjuggler/onionjuggler.conf
for file in /etc/onionjuggler/conf.d/*.conf; do [ -f "${file}" ] && . "${file}"; done
[ -r "${ONIONJUGGLER_CONF}" ] && . "${ONIONJUGGLER_CONF}"

## : ${var:="value"} -> initialize the variable (SC2154) and if empty or unset, use default values
## var=${var%*/} -> removes the trailing slash "/" at the end of directories variables

## system
: "${exec_cmd_alt_user:="sudo"}"
: "${openssl_cmd:="openssl"}"
: "${web_server:="nginx"}"
: "${website_dir:="/var/www"}"; website_dir="${website_dir%*/}"
: "${vanguards_commit:="10942de93f6578f8303f60014f34de2fca345545"}"

## tor defaults
: "${daemon_control:="systemctl"}"; daemon_control="${daemon_control%*/}"
: "${tor_daemon:="tor@default"}"
: "${tor_user:="debian-tor"}"
: "${tor_conf_group:="root"}"
: "${tor_data_dir:="/var/lib/tor"}"; tor_data_dir="${tor_data_dir%*/}"
: "${tor_data_dir_services:="${tor_data_dir}/services"}"; tor_data_dir_services="${tor_data_dir_services%*/}"
: "${tor_data_dir_auth:="${tor_data_dir}/onion_auth"}"; tor_data_dir_auth="${tor_data_dir_auth%*/}"
: "${tor_conf_dir:="/etc/tor"}"; tor_conf_dir="${tor_conf_dir%*/}"
: "${tor_conf:="${tor_conf_dir}/torrc"}"
: "${tor_control_port:="9051"}" ## only the port, not the host
: "${tor_backup_dir:="${HOME}/.onionjuggler/backup"}"; tor_backup_dir="${tor_backup_dir%*/}"

## torbrowser defaults -> TODO: expectation is to automate onion-auth inclusion, but would  have to be more usable than the browser gui version
: "${tor_browser_dir:="${HOME}/.local/share/torbrowser/tbb/$(uname -m)/tor-browser_${LANG%.*}"}"; tor_browser_dir="${tor_browser_dir%*/}"
: "${tor_browser_data_dir:="${tor_browser_dir}/Browser/TorBrowser/Data/Tor"}"; tor_browser_data_dir="${tor_browser_data_dir%*/}"
: "${tor_browser_conf:="${tor_browser_data_dir}/torrc"}"
: "${tor_browser_data_dir_auth:="${tor_browser_data_dir}/onion-auth"}"; tor_browser_data_dir_auth="${tor_browser_data_dir_auth%*/}"


###################
#### FUNCTIONS ####

## set correct permissions for tor directories and files
set_owner_permission(){
  "${exec_cmd_alt_user}" chown -R "${tor_user}:${tor_user}" "${tor_data_dir}"
  "${exec_cmd_alt_user}" chmod 700 "${tor_data_dir}"

  "${exec_cmd_alt_user}" chown -R root:"${tor_conf_group}" "${tor_conf_dir}"
  "${exec_cmd_alt_user}" chmod 755 "${tor_conf_dir}"
  "${exec_cmd_alt_user}" chmod 644 "${tor_conf}"
}


# reloads tor by default or forces to restart if $1 is not empty
# shellcheck disable=SC2120
restarting_tor(){
  set_owner_permission
  : "${signal:="reload"}"
  [ "${signal}" = "r" ] && signal="reload"
  [ "${signal}" = "R" ] && signal="restart"
  printf %s"\n# ${signal}ing tor, please be patient.\n"
  printf "# Signaling tor hanged?\n# Press Ctrl-C and restore the lastest torrc backup with:\n"
  printf "$ onionjuggler-cli restore-torrc --restart\n"
  case "${daemon_control}" in
    systemctl|sv|rcctl) "${exec_cmd_alt_user}" "${daemon_control}" "${signal}" "${tor_daemon}";;
    service) "${exec_cmd_alt_user}" "${daemon_control}" "${tor_daemon}" "${signal}";;
    /etc/rc.d) "${exec_cmd_alt_user}" "${daemon_control}"/"${tor_daemon}" "${signal}";;
    *) rerror_msg "daemon_control value not supported: ${daemon_control}"
  esac
  [ "${?}" -eq 1 ] && error_msg "Failed to ${signal} tor. Check logs first, correct the problem them restart tor."
  printf %s"${green}# ${signal}ed tor succesfully!\n\n${nocolor}"
}


## check if variable is integer
is_integer(){ printf %d "${1}" >/dev/null 2>&1 || error_msg "Not an integer: ${1}" ; }


## checks if the target is valid.
## Address range from 0.0.0.0 to 255.255.255.255. Port ranges from 0 to 65535
## this is not perfect but it is better than nothing
is_addr_port(){
  addr_port="${1}"
  port="${addr_port##*:}"
  addr="${addr_port%%:*}"
  addr_1="${addr%%.*}"
  addr_mid="${addr##*"${addr_1}".}"
  addr_2="${addr_mid%%.*}"
  addr_4="${addr_mid##*.}"
  addr_mid="${addr_mid##*"${addr_2}".}"
  addr_3="${addr_mid%%.*}"

  is_integer "${port}"; is_integer "${addr_1}"; is_integer "${addr_2}"; is_integer "${addr_3}"; is_integer "${addr_4}"

  { [ "${port}" -gt 0 ] && [ "${port}" -le 65535 ] ; } \
  || error_msg "port is not within range: 0 < port <= 65535: ${port}"

  { { [ "${addr_1}" -ge 0 ] && [ "${addr_1}" -le 255 ] ; } \
  && { [ "${addr_2}" -ge 0 ] && [ "${addr_2}" -le 255 ] ; } \
  && { [ "${addr_3}" -ge 0 ] && [ "${addr_3}" -le 255 ] ; } \
  && { [ "${addr_4}" -ge 0 ] && [ "${addr_4}" -le 255 ] ; } ; } \
  || error_msg "target address is not within range: 0.0.0.0 to 255.255.255.255: ${addr}"
}


is_service_dir_empty(){
  [ "$("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_services}"/)" = "" ] && error_msg "Onion services directory is empty. Create a service first before running this command again."
}


## test if service exists to continue the script or output error logs.
## if the service exists, will save the hostname for when requested.
test_service_exists(){
  service="${1}"
  onion_hostname=$("${exec_cmd_alt_user}" -u "${tor_user}" grep ".onion" "${tor_data_dir_services}"/"${service}"/hostname 2>/dev/null)
  [ -z "${onion_hostname}" ] && error_msg "Service does not exist: ${service}"
}


## save the clients names that are inside the <HiddenServiceDir>/authorized_clients/ in list format (CLIENT1,CLIENT2,...)
create_client_list(){
  service="${1}"
  client_name_list="$(printf %s"$("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_services}"/"${service}"/authorized_clients/)" | sed "s/\.auth//g" | tr "\n" ",")"
  client_count=""
  # shellcheck disable=SC2086
  [ -n "${client_name_list}" ] && client_count="$(IFS=','; set -f -- ${client_name_list}; printf %s"${#}")"
}


## save the service names that have a <HiddenServiceDir> in list format (SERV1,SERV2,...)
create_service_list(){ service_name_list=$("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_services}"/ | tr " " ","); }
#create_service_list(){ service_name_list=$("${exec_cmd_alt_user}" grep "HiddenServiceDir ${tor_data_dir_services}/" "${tor_conf}" | sed "s|HiddenServiceDir ${tor_data_dir_services}/||" | tr "\n" " "); }


## loops the parameters
## $1 must be the function to loop
## $2 normally is service, but can be any other parameter (accepts list -> SERV1,SERV2,...)
## $3 normally is client, but can be any other (accepts list -> client1,client2...)
loop_list(){
  for item in $(printf %s"${2}" | tr "," " "); do
    if [ -z "${3}" ]; then
      "${1}" "${item}"
    else
      for subitem in $(printf %s"${3}" | tr "," " "); do
        "${1}" "${item}" "${subitem}"
      done
    fi
  done
}


service_block(){
  process="${1}"
  service="${2}"
  file="${3:-"${tor_conf}"}"
  i=0
  ## print the exact match HiddenServiceDir of the requested service that must end with the service name or with "/", also prit n lines below it
  grep -A 7 -E "^HiddenServiceDir ${tor_data_dir_services}/${service}$|^HiddenServiceDir ${tor_data_dir_services}/${service}/$" "${file}" | while IFS= read -r line; do
    i=$((i+1))
    ## break check
    [ ${i} -gt 1 ] && [ "${line%% *}" = "HiddenServiceDir" ] && break ## break on next HiddenService configuration
    [ -z "${line}" ] && break ## break on empty lines
    printf "%s${line}" | grep -q "^HiddenService" || break ## break on lines that don't begin with HiddenService
    ## if it passed the checks, just do
    case "${process}" in
      print) printf "%s${line}\n";;
      delete) "${exec_cmd_alt_user}" sed -i'' "s|${line}||" "${file}";;
    esac
  done
}


## http://sed.sourceforge.net/local/docs/emulating_unix.txt
tac(){
  "${exec_cmd_alt_user}" sed '1!G;h;$!d' "${1}"
}

cat_squeeze_blank(){
  while :; do
    case "${1}" in
        "/"*|[[:alnum:]]*) files="${files} ${1}"; shift;; ## only consider path starting with "/" or alphanumeric
        *) break;; ## made to break on pipes and everything else
    esac
  done
  # shellcheck disable=SC2086
  "${exec_cmd_alt_user}" sed '1s/^$//p;/./,/^$/!d' ${files}
}

###########################
########## MAIN ###########
"${exec_cmd_alt_user}" sed -i'' 's/\/$//' "${tor_conf}" ## no config should end with '/' to find exact match with the end of line '$'.

case "${command}" in

  ## disabled the service wrongly and don't remember the ports? no worries, will restore the latest torrc.bak
  ## beaware this only works for the torrc, if you deleted your data directory with command "off" combined with "purge" option, the keys will not be restored, instead new ones will be created
  restore-torrc|RESTORE-TORRC)
    printf %s"${cyan}# Restoring torrc with its latest backup${nocolor}\n"
    "${exec_cmd_alt_user}" cp -v "${tor_conf}".bak "${tor_conf}"
    restarting_tor
    printf %s"${green}\n# Done\n${nocolor}"
  ;;


  ## disable a service by removing service torrc's block.
  ## it is raw, services variables should be separated by an empty line per service, else you might get other non-related configuration deleted.
  ## purge is optional, it deletes the <HiddenServiceDir>
  ## will not check if folder or configuration exist, this is cleanup mode
  ## will not use '@all'. Purge is dangerous, purging all service is even more dangerous. Always backup.
  f|off)
    [ -z "${service}" ] && usage
    delete_service(){
      service="${1}"
      ## remove service service data
      case "${action:-}" in
        purge|P)
          printf %s"${red}\n# Deleting Hidden Service data in ${tor_data_dir_services}/${service}${nocolor}\n"
          "${exec_cmd_alt_user}" rm -rfv "${tor_data_dir_services}"/"${service}"
        ;;
        *) printf %s"\n${yellow}# HiddenServiceDiretory was kept${nocolor}\n";;
      esac
      "${exec_cmd_alt_user}" cp "${tor_conf}" "${tor_conf}".bak
      ## remove service paragraph in torrc
      printf %s"# Deleting Hidden Service configuration in ${tor_conf}\n"
      service_block delete "${service}"
      ## substitute multiple sequential empty lines to a single one per sequence
      cat_squeeze_blank "${tor_conf}" | "${exec_cmd_alt_user}" tee "${tor_conf}".tmp >/dev/null && "${exec_cmd_alt_user}" mv "${tor_conf}".tmp "${tor_conf}"
      printf %s"# Disabled service: ${bold}${service}${magenta}\n\n"
    }
    loop_list delete_service "${service}"
    restarting_tor
    printf %s"${green}\n# Done\n${nocolor}"
  ;;


  ## enable a service by configure its own torrc's block, consequentially the <HiddenServiceDir> will be created.
  ## tcp-socket uses addr:port, which can be remote or localhost. It leaks onion address to the local network
  ## unix-socket uses unix:path, which is create a unique name for it. It does not leak onion address to the local network.
  ## virtport is the port to be used by the client when visiting the service.
  ## empty socket will default to unix
  ## empty version will default to 3
  ## empty port will default to 80
  ## target is where the incoming traffic from virtport gets redirected. This option is abscent on unix-socket because the script completes it.
  ##  if target is not specified, will use the same port from virtport and bind to localhost.
  ##  if target only contains the port number and not the address, will bind to localhost.
  ## virtport2 and target 2 are optional
  n|on)
    [ -z "${service}" ] && usage
    : "${version:=3}"; [ "${version}" != "3" ] && error_msg "version=${version} is not available" ## wait for v4 to change this
    : "${socket:=unix}"
    : "${port:=80}"
    port="$(printf %s"${port}" | tr "," " " | tr -s " ")"
    virtport="${port%% *}"

    finish_service_activation(){
      ## remove double empty lines
      cat_squeeze_blank "${tor_conf}" | "${exec_cmd_alt_user}" tee "${tor_conf}".tmp >/dev/null && "${exec_cmd_alt_user}" mv "${tor_conf}".tmp "${tor_conf}"
      restarting_tor
      ## show the Hidden Service address
      test_service_exists "${service}"
      printf %s"\n${cyan}# Hidden Service information:${nocolor}\n"
      command -v qrencode >/dev/null && qrencode -m 2 -t ANSIUTF8 "${onion_hostname}"
      printf %s"Service name    = ${bold}${service}${nocolor}\n"
      printf %s"Service address = ${bold}${magenta}${onion_hostname}${nocolor}\n"
      printf %s"Virtual port    = ${bold}${virtport}${nocolor}\n"
      [ -n "${virtport2}" ] && printf %s"Virtual port 2  = ${bold}${virtport2}${nocolor}\n"
      printf %s"${green}\n# Done\n${nocolor}"
    }

    case "${socket}" in

      tcp)
        ## tor-manual: By default, this option maps the virtual port to the same port on 127.0.0.1 over TCP
        ## Because of that, this project lets the user leave target="" and write target as 127.0.0.1:$virtport
        ## Also, substitutes localhost:port for 127.0.0.1:$port
        ## This measures avoid using the same local port for different services
        ## grep torrc target to see if port is already in use and by which service, reading the file in reverse
        ## Sanity check
        port_mid="${port##*"${virtport}" }"
        target="${port_mid%% *}"
        port_mid="${port_mid##*"${target}" }"
        virtport2="${port_mid%% *}"
        target2="${port##* }"
        { [ "${virtport}" = "${virtport2}" ] || [ "${target}" = "${virtport2}" ]; } && virtport2="" && target2=""
        : "${target:=127.0.0.1:"${virtport}"}"
        ## Standard check for used ports
        target_addr="${target%%:*}"
        target_port="${target##*:}"
        { [ "${target_addr}" = "${target_port}" ] || [ "${target_addr}" = "localhost" ]; } && target="127.0.0.1:${target_port}"
        "${exec_cmd_alt_user}" grep -q "^HiddenServicePort .* ${target}$" "${tor_conf}" && error_msg "target=${target} is already in use.\nINFO: Choose another port or disable the service that is using the wanted port."
        is_integer "${virtport}"; is_addr_port "${target}"
        ## Optional
        if [ -n "${virtport2}" ]; then
          : "${target2:=127.0.0.1:"${virtport2}"}"
          [ "${target}" = "${target2}" ] && error_msg "target=${target} can't be the same as target2=${target2}"
          [ "${virtport}" = "${virtport2}" ] && error_msg "virtport=${virtport} can't be the same as virtport2=${virtport2}"
          ## Standard check for used ports
          target2_addr="${target2%%:*}"
          target2_port="${target2##*:}"
          { [ "${target2_addr}" = "${target2_port}" ] || [ "${target2_addr}" = "localhost" ]; } && target2="127.0.0.1:${target2_port}"
          "${exec_cmd_alt_user}" grep -q "^HiddenServicePort .* ${target2}$" "${tor_conf}" && error_msg "target2=${target2} is already in use.\nINFO: Choose another port or disable the service that is using the wanted port."
          is_integer "${virtport2}"; is_addr_port "${target2}"
        fi
        "${exec_cmd_alt_user}" cp "${tor_conf}" "${tor_conf}".bak
        ## delete any old entry for that servive
        service_block delete "${service}"
        ## add configuration block, empty line after and before it
        printf %s"\n${blue}# Including Hidden Service configuration in ${tor_conf}${nocolor}\n"
        if [ -n "${virtport2}" ]; then
          printf %s"\nHiddenServiceDir ${tor_data_dir_services}/${service}\nHiddenServiceVersion ${version}\nHiddenServicePort ${virtport} ${target}\nHiddenServicePort ${virtport2} ${target2}\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}"
        else
          printf %s"\nHiddenServiceDir ${tor_data_dir_services}/${service}\nHiddenServiceVersion ${version}\nHiddenServicePort ${virtport} ${target}\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}"
        fi
        finish_service_activation
      ;;

      unix)
        is_integer "${virtport}"
        virtport2="${port##* }"
        [ "${virtport}" = "${virtport2}" ] && virtport2=""
        [ -n "${virtport2}" ] && is_integer "${virtport2}" ## var not mandatory
        "${exec_cmd_alt_user}" cp "${tor_conf}" "${tor_conf}".bak
        ## delete any old entry for that servive
        service_block delete "${service}"
        ## add configuration block, empty line after and before it
        printf %s"\n${blue}# Including Hidden Service configuration in ${tor_conf}${nocolor}\n"
        unix_path="unix:/var/run"
        unix_path="${unix_path%*/}/${service}"
        if [ -n "${virtport2}" ]; then
          printf %s"\nHiddenServiceDir ${tor_data_dir_services}/${service}\nHiddenServiceVersion ${version}\nHiddenServicePort ${virtport} ${unix_path}-${virtport}-onion.sock\nHiddenServicePort ${virtport2} ${unix_path}-${virtport2}-onion.sock\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}"
        else
          printf %s"\nHiddenServiceDir ${tor_data_dir_services}/${service}\nHiddenServiceVersion ${version}\nHiddenServicePort ${virtport} ${unix_path}-${virtport}-onion.sock\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}"
        fi
        finish_service_activation
      ;;

      *)
        error_msg "Invalid argument: socket=${socket}"
    esac
  ;;


  ## manage client authorization server side (HiddenServiceDir/authorized_clients/) or client side (ClientOnionAuthDir)
  auth-server|auth-client)
    host="${command#*-}"
    [ -z "${status:-}" ] && usage
    case "${host}" in

      server)
        [ -z "${service}" ] && usage
        is_service_dir_empty
        case "${status}" in

          ## as the onion service operator, make your onion authenticated by generating a pair or public and private keys,
          ## the client pub key is automatically saved inside <HiddenServiceDir>/authorized_clients/alice.auth
          ## the client private key is shown in the screen and the key file deleted
          ## the onion service operator should send the private key for the desired client
          n|on)
            [ -z "${client}" ] && usage
            #printf "\n# Generating keys to access onion service (Client Authorization) ...\n"
            auth_server_add(){
              service="${1}"
              client="${2}"
              test_service_exists "${service}"
              ## Generate pem and derive pub and priv keys
              "${openssl_cmd}" genpkey -algorithm x25519 -out /tmp/k1.prv.pem
              grep -v " PRIVATE KEY" /tmp/k1.prv.pem | base64pem -d | tail -c 32 | base32 | sed "s/=//g" > /tmp/k1.prv.key
              "${openssl_cmd}" pkey -in /tmp/k1.prv.pem -pubout | grep -v " PUBLIC KEY" | base64pem -d | tail -c 32 | base32 | sed "s/=//g" > /tmp/k1.pub.key
              ## save variables
              client_pub_key=$(cat /tmp/k1.pub.key)
              client_priv_key=$(cat /tmp/k1.prv.key)
              onion_hostaname_without_onion="${onion_hostname%.onion}"
              client_priv_key_config="${onion_hostname%.onion}:descriptor:x25519:${client_priv_key}"
              client_pub_key_config="descriptor:x25519:${client_pub_key}"
              # Server side configuration
              printf %s"${client_pub_key_config}\n" | "${exec_cmd_alt_user}" tee "${tor_data_dir_services}"/"${service}"/authorized_clients/"${client}".auth >/dev/null
              ## Client side configuration
              printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
              printf %s"service=${bold}${service}${nocolor}\n"
              printf %s"client=${bold}${client}${nocolor}\n"
              printf %s"onion_hostname=${bold}${magenta}${onion_hostname}${nocolor}\n"
              printf %s"client_pub_key=${bold}${client_pub_key}${nocolor}\n"
              printf %s"client_pub_key_config=${bold}${client_pub_key_config}${nocolor}\n"
              printf %s"client_priv_key=${bold}${client_priv_key}${nocolor}\n"
              printf %s"client_priv_key_config=${bold}${client_priv_key_config}${nocolor}\n"
              printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"
              ## Delete pem and keys
              "${exec_cmd_alt_user}" rm -f /tmp/k1.pub.key /tmp/k1.prv.key /tmp/k1.prv.pem
            }
            [ "${service}" = "@all" ] && { create_service_list ; service="${service_name_list}" ; }
            [ "${client}" = "@all" ] && error_msg "Client name cannot be @all, it is a restricted wildcard for referring to all clients, not a name per se."
            if [ -n "${client_pub_key}" ]; then
              test_service_exists "${service}"
              client_pub_key_config="descriptor:x25519:${client_pub_key}"
              printf %s"${client_pub_key_config}" | "${exec_cmd_alt_user}" tee "${tor_data_dir_services}"/"${service}"/authorized_clients/"${client}".auth >/dev/null
              printf "\n# Server side authorization configured\n\n"
              printf %s" client_pub_key_config=${client_pub_key_config}\n"
              printf "\n# As you inserted the public key manually, we expect that the client already has the private key\n"
            else
              loop_list auth_server_add "${service}" "${client}"
              instructions_auth
            fi
            restarting_tor
            printf %s"${green}\n# Done\n${nocolor}"
          ;;

          ## as the onion service operator, after making your onion service authenticated, you can also remove a specific client authorization
          ## if no clients are present, the service will be available to anyone that has the onion service address
          f|off)
                [ -z "${client}" ] && usage
            auth_server_remove_clients(){
              service="${1}"
              client="${2}"
              printf %s"Service  = ${service}\n"
              if [ "${client}" = "@all" ]; then
                printf "Client   = @all\n\n"
                "${exec_cmd_alt_user}" rm -fv "${tor_data_dir_services}"/"${service}"/authorized_clients/*.auth
              else
                printf %s"Client   = ${client}\n\n"
                "${exec_cmd_alt_user}" rm -fv "${tor_data_dir_services}"/"${service}"/authorized_clients/"${client}".auth
              fi
            }
            [ -z "${service}" ] && error_msg "service is missing"
            if [ "${service}" = "@all" ]; then
              printf %s"${red}# Removing client authorization for all services.${nocolor}\n"
              create_service_list; service="${service_name_list}"
              [ "${client}" = "@all" ] \
              && printf %s"${red}# Removing client authorization for all clients.\n# The service is now accessible for anyone with the onion address.${nocolor}\n\n" \
              || printf "# If any client remains, the service will still be authenticated.\n\n"
            else
              printf %s"# Removing client authorization for the services: ${service}\n"
              [ "${client}" = "@all" ] \
              && printf %s"${red}# Removing client authorization for all clients.\n# The service is now accessible for anyone with the onion address.${nocolor}\n\n" \
              || printf "# If any client remains, the service will still be authenticated.\n\n"
            fi
            loop_list auth_server_remove_clients "${service}" "${client}"
            restarting_tor
            printf %s"${green}\n# Done\n${nocolor}"
          ;;

          l|list)
            auth_server_list(){
              service="${1}"
              test_service_exists "${service}"
              create_client_list "${service}"
              if [ -n "${client_count}" ]; then
                printf %s"\nService  = ${bold}${service}${nocolor}\n"
                [ -n "${client_name_list}" ] && printf %s"Clients  = ${bold}${client_name_list} (${client_count})${nocolor}\n"
                for auth in $("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_services}/${service}/authorized_clients/"); do
                  printf %s"\n# File name: ${bold}${auth}${nocolor}\n"
                  printf %s"# Content:   ${bold}$("${exec_cmd_alt_user}" -u "${tor_user}" grep "descriptor:x25519:" "${tor_data_dir_services}"/"${service}"/authorized_clients/"${auth}")${nocolor}\n"
                done
                printf "\n"
              else
                printf %s"\n${yellow}# No clients for Hidden Service: ${service}${nocolor}\n\n"
              fi
            }
            printf %s"${cyan}# Authorized clients for Hidden Services${nocolor}\n"
            [ "${service}" = "@all" ] && { create_service_list; service="${service_name_list}"; }
            loop_list auth_server_list "${service}"
            printf %s"${green}\n# Done\n${nocolor}"
          ;;

          *)
            error_msg "Invalid argument: status=${status}"
        esac
      ;;


      client)
        case "${status}" in

          ## as the onion service client, add a key given by the onion service operator to authenticate yourself inside ClientOnionAuthDir
          ## The suffix '.auth_private' should not be mentioned, it will be automatically inserted when mentioning the name of the file.
          ## private key format must be: <onion-addr-without-.onion-part>:descriptor:x25519:<private-key>
          ## use the onion hostname as the file name, this avoid overriding the file by mistake and it indicates outside of the file for which service it refers to (of course it is written inside also)
          ## adding to Tor Browser automatically not supported yet
          n|on)
            [ -z "${service}" ] && usage
            ## removes protocol such as http(s)://, ssh:// and git:// from the front of the address and trailing / at the end of the onion to clean it and only show the hostname (address.onion)
            onion="$(printf %s"${onion}\n" | sed "s|.*://||" | sed "s|/$||")"
            onion_hostaname_without_onion="${onion%.onion}"
            [ "${onion##*.}" != "onion" ] && error_msg "ONION_DOMAIN is invalid, suffix is not '.onion'"
            [ "${onion_hostaname_without_onion%%*[^a-z2-7]*}" ] || error_msg "ONION_DOMAIN is invalid, it is not within base32 alphabet lower-case encoding [a-z][2-7]"
            [ "${#onion}" = "62" ] || error_msg "ONION_DOMAIN is invalid, LENGTH=${#onion} is different than 62 characters (<56-char-base32>.onion)"
            "${exec_cmd_alt_user}" cp "${tor_conf}" "${tor_conf}".bak
            grep -q "ClientOnionAuthDir" "${tor_conf}" && { printf %s"\nClientOnionAuthDir ${tor_data_dir_auth}\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}"; }
            "${exec_cmd_alt_user}" -u "${tor_user}" mkdir -p "${tor_data_dir_auth}"
            if [ -z "${client_priv_key}" ]; then
              ## Generate pem and derive pub and priv keys
              "${openssl_cmd}" genpkey -algorithm x25519 -out /tmp/k1.prv.pem
              grep -v "PRIVATE KEY" /tmp/k1.prv.pem | base64pem -d | tail -c 32 | base32 | sed 's/=//g' > /tmp/k1.prv.key
              "${openssl_cmd}" pkey -in /tmp/k1.prv.pem -pubout | grep -v "PUBLIC KEY" | base64pem -d | tail -c 32 | base32 | sed 's/=//g' > /tmp/k1.pub.key
              ## save variables
              client_pub_key=$(cat /tmp/k1.pub.key)
              client_priv_key=$(cat /tmp/k1.prv.key)
              client_priv_key_config="${onion%.onion}:descriptor:x25519:${client_priv_key}"
              client_pub_key_config="descriptor:x25519:${client_pub_key}"
              ## Delete pem and keys
              "${exec_cmd_alt_user}" rm -f /tmp/k1.pub.key /tmp/k1.prv.key /tmp/k1.prv.pem
              # Client side configuration
              printf %s"${client_priv_key_config}\n" | "${exec_cmd_alt_user}" tee "${tor_data_dir_auth}"/"${onion}".auth_private >/dev/null
              printf "# Client side authorization configured\n"
              printf "# This is your private key, keep it safe, keep it hidden:\n\n"
              printf %s" client_priv_key=${bold}${client_priv_key}${nocolor}\n"
              printf %s" client_priv_key_config=${bold}${client_priv_key_config}${nocolor}\n"
              printf "\n# Now it depends on the service operator to authorize you client public key\n\n"
              ## Server side configuration
              printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
              printf "# Send the public key and instructions to the onion service operator\n\n"
              printf %s" onion=${bold}${onion}${nocolor}\n"
              printf %s" client_pub_key=${bold}${client_pub_key}${nocolor}\n"
              printf %s" client_pub_key_config=${bold}descriptor:x25519:${client_pub_key}${nocolor}\n\n"
              printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
            else
              client_priv_key_config="${onion%.onion}:descriptor:x25519:${client_priv_key}"
              printf %s"${client_priv_key_config}\n" | "${exec_cmd_alt_user}" tee "${tor_data_dir_auth}"/"${onion}".auth_private >/dev/null
              printf "\n# Client side authorization configured\n"
              printf %s"\n client_priv_key_config=${bold}${client_priv_key_config}${nocolor}\n"
              printf "\n# As you inserted the private key manually, we expect that you have already sent/received the public key to/from the onion service operator\n"
            fi
            printf %s"${green}\n# Done\n${nocolor}"
          ;;

          ## as the onion service client, delete '.auth_private' files from ClientOnionAuthDir that are not valid or has no use anymore
          f|off)
            [ -z "${onion}" ] && usage
            onion="$(printf %s"${onion}\n" | sed "s|.*://||" | sed "s|/.*$||")"
            auth_client_remove  (){
              onion="${1}"
              printf %s"\n{${red}# Removing ${tor_data_dir_auth}/${onion}.auth_private${nocolor}"
              "${exec_cmd_alt_user}" rm -fv "${tor_data_dir_auth}"/"${onion}".auth_private
            }
            if [ "$("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_auth}")" != "" ]; then
              loop_list auth_client_remove "${onion}"
              printf "\n# Client side authorization removed\n"
              printf %s"${green}\n# Done\n${nocolor}"
            else
              error_msg "ClientOnionAuthDir is empty"
            fi
          ;;

          l|list)
            if [ "$("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_auth}")" != "" ]; then
              printf %s"# ClientOnionAuthDir ${tor_data_dir_auth}\n"
              for auth in $("${exec_cmd_alt_user}" -u "${tor_user}" ls "${tor_data_dir_auth}"); do
                printf %s"\n# File name: ${bold}${auth}${nocolor}\n"
                printf %s"# Content:   ${bold}$("${exec_cmd_alt_user}" -u "${tor_user}" grep "descriptor:x25519:" "${tor_data_dir_auth}"/"${auth}")${nocolor}"
              done
              printf "\n"
              printf %s"${green}\n# Done\n${nocolor}"
            else
              error_msg "ClientOnionAuthDir is empty"
            fi
          ;;

          *)
            error_msg "Invalid argument: status=${status}"
        esac
      ;;

      *)
        error_msg "Invalid argument: host=${host}"
    esac
  ;;


  ## change service hostname by deleting its ed25519 pub and priv keys.
  ## <HiddenServiceDir>/authorized_clients/ because the would need to update their '.auth_private' file with the new onion address anyway and for security reasons.
  ## @all will read through all services folders and execute the commands.
  renew)
    [ -z "${service}" ] && usage
    is_service_dir_empty

    renew_delete_old(){
      service="${1}"
      test_service_exists "${service}"
      eval "${service}"_hostname_old="${onion_hostname}"
      printf %s"\n${cyan}$# Renewing hostname of the service: ${bold}${service}${nocolor}\n"
      "${exec_cmd_alt_user}" rm -fv "${tor_data_dir_services}"/"${service}"/hs_ed25519_secret_key
      "${exec_cmd_alt_user}" rm -fv "${tor_data_dir_services}"/"${service}"/hs_ed25519_public_key
      "${exec_cmd_alt_user}" rm -fv "${tor_data_dir_services}"/"${service}"/hostname
    }
    renew_get_new(){
      service="${1}"
      test_service_exists "${service}"
      create_client_list "${service}"
      eval "${service}"_hostname_new="${onion_hostname}"
      eval hostname_old='$'"${service}"_hostname_old
      eval hostname_new='$'"${service}"_hostname_new
      # shellcheck disable=SC2154
      if [ "${hostname_old}" != "${hostname_new}" ]; then
        printf %s"${green}# Onion hostname renewed for the service: ${bold}${service}${nocolor}\nOld = ${underline}${hostname_old}${nocolor}\nNew = ${underline}${hostname_new}${nocolor}\n"
        [ -n "${client_name_list}" ] && printf %s"${yellow}# Info: Notify the clients ${client_name_list} to update their bookmarks to the hostname (including modifying the '.auth_private' file accordingly).\n"
        printf "\n"
      else
        error_msg "# Failed to renew service: ${service}\n"
      fi
    }

    [ "${service}" = "@all" ] && { create_service_list; service="${service_name_list}"; }
    service_save="${service}"
    loop_list renew_delete_old "${service_save}"
    restarting_tor
    sleep 0.5
    loop_list renew_get_new "${service_save}"
    printf %s"${green}\n# Done\n${nocolor}"
  ;;


  ## show all the necessary information to access the service such as the hostname and the QR encoded hostname to scan for Tor Browser Mobile
  ## show the clients names and quantity, as well as the service torrc's block
  ## @all will read through all services folders and execute the commands
  l|list)
    is_service_dir_empty
    [ -z "${service}" ] && usage
    get_service_info(){
      service="${1}"
      test_service_exists "${service}"
      j=$((j+1))
      [ ${j} -eq 1 ] && printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
      ## save clients names that are inside <HiddenServiceDir>/authorized_clients/
      create_client_list "${service}"
      if [ "${action}" != "q" ] && [ "${action}" != "quiet" ]; then
        command -v qrencode >/dev/null && qrencode -m 2 -t ANSIUTF8 "${onion_hostname}"
      fi
      printf %s"Address  = ${bold}${magenta}${onion_hostname}${nocolor}\n"
      printf %s"Service  = ${bold}${service}${nocolor}\n"
      [ -n "${client_name_list}" ] && printf %s"Clients  = ${bold}${client_name_list} (${client_count})${nocolor}\n"
      if "${exec_cmd_alt_user}" grep -q "^HiddenServiceDir ${tor_data_dir_services}/${service}$" "${tor_conf}"; then
        printf %s"Status   = ${bold}${green}active${nocolor}\n" && service_block print "${service}"
      else
        printf %s"Status   = ${bold}${yellow}inactive${nocolor}\n"
      fi
      printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
    }
    j=0
    [ "${service}" = "@all" ] && { create_service_list; service="${service_name_list}"; }
    loop_list get_service_info "${service}"
    printf %s"${green}\n# Done\n${nocolor}"
  ;;


  ## start serving files with a webserver for a specific onion service and specific website folder
  web)
    [ -z "${status}" ] && usage
    if [ "${web_server}" != "nginx" ] && [ "${web_server}" != "apache2" ] && [ "${web_server}" != "openbsd-httpd" ]; then
      error_msg "web_server can be either 'nginx' or 'apache2', not '${web_server}'"
    fi

    case "${status}" in

      n|on)
        is_service_dir_empty
        { [ -z "${service}" ] || [ -z "${folder}" ]; } && usage
        test_service_exists "${service}"
        port=$(service_block print "${service}" | grep "HiddenServicePort" | tail -n 1)
        only_ports=${port#* }
        virtport=${only_ports% *}
        target=${only_ports##* }
        target_addr="${target%%:*}"
        target_port="${target##*:}"
        case "${web_server}" in
          apache2|openbsd-httpd) printf %s"${target}" | grep -q "unix" && error_msg "Web server '${web_server}' does not accept listening on a unix domain socket." ;;
        esac
        printf %s"${cyan}# Activating web server for the onion service: ${service}${nocolor}\n\n"
        case "${web_server}" in
          nginx|apache2)
            ## If $folder starts with '~/' or '/', user specified the path, if started with anything else expect a folder inside ${website_dir}
            case "${folder}" in
              ~/*|/*) :;;
              *) folder="${website_dir}/${folder}";;
            esac
          ;;
          openbsd-httpd)
            ## TODO: website_dir is not being used here, the chroot dir is /var/www and the root expected is /htdocs
            case "${folder}" in
              "htdocs"*) folder="/${folder}";;
              "/htdocs"*|/*) :;;
              *) folder="/htdocs/${folder}";;
            esac
          ;;
        esac

        case "${web_server}" in
          nginx)
            printf %s"
server {
    listen ${target};
    server_name ${onion_hostname};

    access_log /var/log/nginx/access_${service}.log;
    error_log /var/log/nginx/error_${service}.log;

    root ${folder};
    index index.html index.htm index.php;
}
" | "${exec_cmd_alt_user}" tee /etc/"${web_server}"/sites-available/
            "${exec_cmd_alt_user}" ln -sfv /etc/"${web_server}"/sites-available/"${service}"-onion.conf /etc/"${web_server}"/sites-enabled/
          ;;
          apache)
            printf %s"
<VirtualHost ${target_addr}:${target_port}>
    ServerName ${onion_hostname}
    DocumentRoot ${folder}
    ErrorLog /var/log/apache2/${service}.log
</VirtualHost>
" | "${exec_cmd_alt_user}" tee /etc/"${web_server}"/sites-available/
            "${exec_cmd_alt_user}" ln -sfv /etc/"${web_server}"/sites-available/"${service}"-onion.conf /etc/"${web_server}"/sites-enabled/
          ;;
          openbsd-httpd)
            printf %s"
server \"${onion_hostname}\" {
  listen on ${target_addr} port ${target_port}
  root \"${folder}\"
}
" | "${exec_cmd_alt_user}" tee -a /etc/httpd.conf
          ;;
        esac
        #printf "\n# Web server configuration:\n\n"
        #"${exec_cmd_alt_user}" cat /tmp/"${service}"-onion.conf
        #while IFS= read -r line || [ -n "$line" ]; do printf '%s\n' "$line"; done < "/tmp/${service}-onion.conf"
        printf "\n# Reloading web server to apply new configuration\n"
        case "${web_server}" in
          nginx) "${exec_cmd_alt_user}" nginx -t && "${exec_cmd_alt_user}" nginx -s reload;;
          apache2) "${exec_cmd_alt_user}" apache2 -t && "${exec_cmd_alt_user}" apache -k graceful;;
          openbsd-httpd) "${exec_cmd_alt_user}" httpd -n && "${exec_cmd_alt_user}" rcctl reload httpd;;
        esac
        [ "${?}" -eq 1 ] && error_msg "Failed to reload ${web_server}, you must restart it manually before running this script again."
        #"${exec_cmd_alt_user}" rm -f /tmp/"${service}"-onion.conf
        printf %s"\n# Address: ${magenta}http://${onion_hostname}:${virtport}${nocolor}\n"
        printf %s"${green}\n# Done\n${nocolor}"
      ;;

      f|off)
        [ -z "${service}" ] && usage
        disable_site(){
          service="${1}"
          printf %s"\n# Stopping website of the service: ${service}\n"
          case "${web_server}" in
            nginx|apache2)
              "${exec_cmd_alt_user}" rm -fv /etc/"${web_server}"/sites-available/"${service}"-onion.conf ## for cleanliness
              "${exec_cmd_alt_user}" rm -fv /etc/"${web_server}"/sites-enabled/"${service}"-onion.conf
            ;;
            openbsd-httpd)
              ## TODO
            ;;
          esac
        }
        loop_list disable_site "${service}" 0
        printf %s"\n${blue}# Reloading web server to apply new configuration${nocolor}\n"
        case "${web_server}" in
          nginx) "${exec_cmd_alt_user}" nginx -t && "${exec_cmd_alt_user}" nginx -s reload;;
          apache2) "${exec_cmd_alt_user}" apache2 -t && "${exec_cmd_alt_user}" apache2 -k graceful;;
          openbsd-httpd) "${exec_cmd_alt_user}" httpd -n && "${exec_cmd_alt_user}" rcctl reload httpd;;
        esac
        printf %s"${green}\n# Done\n${nocolor}"
      ;;

      l|list)
        printf %s"# Web server = ${web_server}\n\n"
        printf %s"${bold}# Enabled websites:${nocolor}"
        ## todo for openbsd-httpd
        sites_enabled=$("${exec_cmd_alt_user}" ls /etc/"${web_server}"/sites-enabled/ | sed "s/-onion.conf//g")
        [ -n "${sites_enabled}" ] && printf %s"\n${sites_enabled}\n" || printf " No website enabled\n"
      ;;

      *)
        error_msg "Invalid argument: status=${status}"
    esac
  ;;


  ## guide to add onion-location to redirect tor users when using your plainnet site to the onion service address
  ## https://matt.traudt.xyz/posts/website-setup/
  location)
    is_service_dir_empty
    { [ -z "${action}" ] || [ -z "${service}" ]; } && usage
    test_service_exists "${service}"

    start_location(){
    printf "# Onion-Location guided steps
\n* The below output is printing text, no file was modified by this script, therefore, user needs to manually configure.
* For web servers, include header line inside the plainnet ssl block (port 443).
* It assumes you know how to run a plainnet server, configuration is an example and should be adapted to your needs.
\n# Add to your \"%s${action}\" configuration:\n"
}

  finish_location(){
  printf "\n# Test redirection
\n* Open the web site in Tor Browser and a purple pill will appear in the address bar; or
* Fetch the web site HTTP headers and look for onion-location entry and the onion service address:
\n\twget --server-response --spider your-website.tld\n"
}

    case "${action}" in

      nginx)
        start_location
        printf "
server {\n\tlisten 443 ssl http2;\n\tadd_header Onion-Location http://""%s${onion_hostname}""\$request_uri;\n}
\n# Reload web server:\n\n\t${exec_cmd_alt_user} nginx -t && ${exec_cmd_alt_user} nginx -s reload\n"
        finish_location
      ;;

      apache2)
        start_location
        printf "
<VirtualHost *:443>\n\tHeader set Onion-Location \"http://%s${onion_hostname}%%{REQUEST_URI}s\"\n</Virtualhost>
\n# Enable headers and rewrite modules:\n\n\t${exec_cmd_alt_user} a2enmod headers rewrite
\n# Reload web server:\n\n\t${exec_cmd_alt_user} apache2 -t && ${exec_cmd_alt_user} apache2 -k graceful\n"
        finish_location
      ;;

      html|HTML)
        start_location
        printf "
<meta http-equiv=\"onion-location\" content=\"http://%s${onion_hostname}\"/>
\n# Reload web server that you use:\n\n\t${exec_cmd_alt_user} nginx -t && ${exec_cmd_alt_user} nginx -s reload\n\t# or\n\t${exec_cmd_alt_user} apache2 -t && ${exec_cmd_alt_user} apache2 -k graceful\n"
        finish_location
      ;;

      *)
        error_msg "Invalid argument: action=${action}"
    esac
  ;;


  backup)
    [ -z "${action}" ] && usage
    case "${action}" in

      ## full backup needede to restore all of your hidden services and client keys
      ## folders/files included: <torrc>, <DataDir>/services/, <DataDir>/onion_auth/
      M|make)
        tor_backup_file="tor-onion-services-backup-$(date +%Y-%m-%d-%H'h'-%M'm').tar.gz"
        printf %s"${cyan}# Backing up the services dir, onion_auth dir and the torrc${nocolor}\n\n"
        mkdir -p "${tor_backup_dir}"
        ## these lines are necessary to copy the full path when creating the compressed archive
        "${exec_cmd_alt_user}" cp "${tor_conf}" "${tor_conf}".rest
        printf '\n%s\n\n' "$("${exec_cmd_alt_user}" grep "ClientOnionAuthDir" "${tor_conf}")" | "${exec_cmd_alt_user}" tee "${tor_conf}".tmp >/dev/null
        for service in $("${exec_cmd_alt_user}" grep "HiddenServiceDir ${tor_data_dir_services}/" "${tor_conf}" | sed "s|HiddenServiceDir ${tor_data_dir_services}/||" | tr "\n" " "); do
          printf "\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}".tmp >/dev/null
          service_block print "${service}" "${tor_conf}" | "${exec_cmd_alt_user}" tee -a "${tor_conf}".tmp >/dev/null
          printf "\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}".tmp >/dev/null
        done
        "${exec_cmd_alt_user}" mv "${tor_conf}".tmp "${tor_conf}"
        "${exec_cmd_alt_user}" tar -cpzvf "${tor_backup_dir}"/"${tor_backup_file}" "${tor_data_dir_services}" "${tor_data_dir_auth}" "${tor_conf}" 2>/dev/null
        "${exec_cmd_alt_user}" mv "${tor_conf}".rest "${tor_conf}"
        "${exec_cmd_alt_user}" chown -R "${USER}:${USER}" "${tor_backup_dir}"
        set_owner_permission
        while :; do
          command -v sha256sum >/dev/null && checksum_sha256="sha256sum" && break
          command -v shasum >/dev/null && checksum_sha256="shasum -a 256" && break
          command -v sha256 >/dev/null && checksum_sha256="sha256" && break
          command -v openssl >/dev/null && checksum_sha256="openssl dgst -sha256 -r" && break
          command -v digest >/dev/null && checksum_sha256="digest -a sha256" && break
          break
        done
        [ -n "${checksum_sha256}" ] && printf %s"\nsha256=$(${checksum_sha256} "${tor_backup_dir}"/"${tor_backup_file}")\n"
        printf %s"${green}\n# Done\n${nocolor}"
      ;;

      ## restore backup
      ## backup tar file will be extracted and integrated into their respective tor folders
      I|integrate)
        "${exec_cmd_alt_user}" -u "${USER}" mkdir -p "${tor_backup_dir}"/integrate
        tor_backup_file=$("${exec_cmd_alt_user}" -u "${USER}" ls "${tor_backup_dir}" | grep ".tar.gz" | tail -n -1)
        printf %s"${cyan}# Integrating backup from file: ${bold}${tor_backup_file}${nocolor}\n\n"
        printf "# Extracting the archive\n\n"
        "${exec_cmd_alt_user}" tar -xpzvf "${tor_backup_dir}"/"${tor_backup_file}" -C "${tor_backup_dir}"/integrate
        "${exec_cmd_alt_user}" chown -R "${USER}:${USER}" "${tor_backup_dir}"
        "${exec_cmd_alt_user}" cp -rf "${tor_backup_dir}"/integrate"${tor_data_dir_services}"/* "${tor_data_dir_services}"/
        "${exec_cmd_alt_user}" cp -rf "${tor_backup_dir}"/integrate"${tor_data_dir_auth}"/* "${tor_data_dir_auth}"/
        client_auth_config="$("${exec_cmd_alt_user}" grep "ClientOnionAuthDir" "${tor_backup_dir}"/integrate"${tor_conf}")"
        if [ -n "${client_auth_config}" ]; then
          "${exec_cmd_alt_user}" sed -i'' "/ClientOnionAuthDir .*/d" "${tor_conf}"
          printf '\n%s\n\n' "${client_auth_config}" "${tor_conf}"
          "${exec_cmd_alt_user}" sed -i'' "/ClientOnionAuthDir .*/d" "${tor_backup_dir}"/integrate"${tor_conf}"
        fi
        cat_squeeze_blank "${tor_conf}" "${tor_backup_dir}"/integrate"${tor_conf}" | "${exec_cmd_alt_user}" tee "${tor_conf}".tmp >/dev/null
        "${exec_cmd_alt_user}" mv "${tor_conf}".tmp "${tor_conf}"
        "${exec_cmd_alt_user}" rm -rf "${tor_backup_dir}"/integrate
        restarting_tor
        printf %s"${green}\n# Done\n${nocolor}"
      ;;

      *)
        error_msg "Invalid argument: action=${action}"
    esac
  ;;


  ## This addon protects against guard discovery and related traffic analysis attacks.
  ## A guard discovery attack enables an adversary to determine the guard node(s) that are in use by a Tor client and/or Tor onion service.
  ## Once the guard node is known, traffic analysis attacks that can deanonymize an onion service (or onion service user) become easier.
  ## TODO: hardening (as in $ systemctl cat tor@default), but got permission denied: unable to read '/run/tor/control.authcookie', also see $ systemd-analyze security vanguards@default.service
  ## TODO -> Vanguards sample service configuration for other service managers
  vanguards)
    [ -z "${action}" ] && usage
    [ "${daemon_control}" != "systemctl" ] && error_msg "Unfortunately, OnionJuggler has only implemented Vanguards with Systemd (systemctl).\n Help improve this by submitting a merge request."

    while :; do
      command -v python3 >/dev/null && python_path="$(command -v python3)" && break
      command -v python >/dev/null && python_path="$(command -v python)" && break
    done
    [ -z "${python_path}" ] && error_msg "Python is not installed and it is needed for Vanguards."

    vanguards_config(){
      "${exec_cmd_alt_user}" cp "${tor_conf}" "${tor_conf}".bak
      ## Keep config with the torrc and torsocks.conf
      "${exec_cmd_alt_user}" cp -v "${tor_data_dir}"/vanguards/vanguards-example.conf "${tor_conf_dir}"/vanguards.conf
      "${exec_cmd_alt_user}" sed -i'' "s|tor_control_port =.*|tor_control_port = ${tor_control_port}|g" "${tor_conf_dir}"/vanguards.conf
      "${exec_cmd_alt_user}" sed -i'' "s|logfile = .*|logfile = /var/log/tor/vanguards.log|g" "${tor_conf_dir}"/vanguards.conf
      ## Control and Authentication methods are needed. Use the easiest to configure if the manual ones are not present, else do nothing.
      ## Control methods are Port (default: 9051) and Socket (default: /run/tor/control). Prefer port because socket path may differ on different systems https://github.com/mikeperry-tor/vanguards/pull/54#issuecomment-812185302.
      if ! grep -q "ControlPort ${tor_control_port}" "${tor_conf}" && ! grep -q "ControlSocket" "${tor_conf}"; then
        "${exec_cmd_alt_user}" sed -i'' "s/ControlPort .*/ControlPort ${tor_control_port}/" "${tor_conf}"
        grep -q "ControlPort ${tor_control_port}" "${tor_conf}" || printf %s"\nControlPort ${tor_control_port}\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}" >/dev/null
      fi
      ## Authentication methods are Cookie (default: 0) and HashedPassword, to read the "control_auth_cookie". Prefer cookie because else a password is needed. If any method was already configured, use it.
      if ! grep -q "CookieAuthentication 1" "${tor_conf}" && ! grep -q "HashedControlPassword" "${tor_conf}"; then
        "${exec_cmd_alt_user}" sed -i'' "s/CookieAuthentication .*/CookieAuthentication 1/" "${tor_conf}"
        grep -q "CookieAuthentication" "${tor_conf}" || printf "\nCookieAuthentication 1\n\n" | "${exec_cmd_alt_user}" tee -a "${tor_conf}"  >/dev/null
      fi
      ## Generate Vanguards service
      printf %s"
[Unit]
Description=Additional protections for Tor onion services
Wants=${tor_daemon}
After=network.target nss-lookup.target

[Service]
WorkingDirectory=${tor_data_dir}/vanguards
ExecStart=${python_path} src/vanguards.py --config ${tor_conf_dir}/vanguards.conf
User=${tor_user}
Group=${tor_user}
Type=simple
Restart=always

[Install]
WantedBy=multi-user.target
" | "${exec_cmd_alt_user}" tee /tmp/vanguards@default.service
      "${exec_cmd_alt_user}" cp /tmp/vanguards@default.service /etc/systemd/system/
      printf "\n>>>>>>>>>>>>>>>>>>>\n"
      while IFS= read -r line || [ -n "$line" ]; do printf '%s\n' "$line"; done < "/tmp/vanguards@default.service"
      #cat /tmp/vanguards@default.service
      printf ">>>>>>>>>>>>>>>>>>>\n\n"
      restarting_tor
      "${exec_cmd_alt_user}" systemctl daemon-reload
      "${exec_cmd_alt_user}" systemctl enable vanguards@default.service
      "${exec_cmd_alt_user}" systemctl restart vanguards@default.service
      "${exec_cmd_alt_user}" systemctl status vanguards@default.service --no-pager
      printf %s"${green}\n# Done\n${nocolor}"
    }

    case "${action}" in
      n|on)
        if [ ! -d "${tor_data_dir}/vanguards" ]; then
          printf %s"${cyan}# Installing Vanguards${nocolor}\n\n"
          "${exec_cmd_alt_user}" -u "${tor_user}" git clone https://github.com/mikeperry-tor/vanguards.git "${tor_data_dir}/vanguards"
        else
          printf %s"${cyan}# Upgrading Vanguards${nocolor}\n\n"
          "${exec_cmd_alt_user}" -u "${tor_user}" git -C "${tor_data_dir}"/vanguards pull -p --rebase=false
        fi
        "${exec_cmd_alt_user}" -u "${tor_user}" git -C "${tor_data_dir}"/vanguards reset --hard "${vanguards_commit}"
        "${exec_cmd_alt_user}" -u "${tor_user}" git -C "${tor_data_dir}"/vanguards show
        vanguards_version="$(grep "__version__ = " src/vanguards/__init__.py | tr "\"" " " | sed "s/__version__ =  //")"
        printf %s"Installed Vanguards v${vanguards_version}\n"
        "${exec_cmd_alt_user}" cp "${tor_data_dir}"/vanguards/vanguards.1 /usr/local/man/man1/
        vanguards_config
      ;;

      f|off)
        printf %s"${red}# Removing Vanguards${nocolor}\n\n"
        "${exec_cmd_alt_user}" rm -rfv "${tor_data_dir}"/vanguards
        printf %s"${green}\n# Done\n${nocolor}"
      ;;

      l|list)
        "${exec_cmd_alt_user}" tail -f -n 25 /var/log/tor/vanguards.log
      ;;

      *)
        error_msg "Invalid argument: action=${action}"
    esac
  ;;

  *) usage

esac
